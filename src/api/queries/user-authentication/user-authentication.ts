/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Eternal Anvil (Backend)
 * The backend server for the Eternal Anvil.
 * OpenAPI spec version: v0.0.1
 */
import { useMutation } from '@tanstack/react-query';
import type {
  MutationFunction,
  UseMutationOptions,
  UseMutationResult,
} from '@tanstack/react-query';

import type {
  TokenBlacklist,
  TokenObtainPair,
  TokenRefresh,
  UserRegister,
  UsersLoginCreateErrorResponse400,
  UsersLoginRefreshCreateErrorResponse400,
  UsersLogoutCreateErrorResponse400,
  UsersRegisterCreate403,
  UsersRegisterCreateErrorResponse400,
} from '../../models';
import { queryInstance } from '../../queryInstance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
  ? A
  : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
  >;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * Endpoint to login a user and obtain a pair of `(access_token, refresh_token)`.
 */
export const usersLoginCreate = (
  tokenObtainPair: NonReadonly<TokenObtainPair>,
  options?: SecondParameter<typeof queryInstance>,
) => queryInstance<TokenObtainPair>(
  { url: '/users/login/',
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tokenObtainPair },
  options,
);

export const getUsersLoginCreateMutationOptions = <TError = UsersLoginCreateErrorResponse400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersLoginCreate>>, TError, { data: NonReadonly<TokenObtainPair> }, TContext>, request?: SecondParameter<typeof queryInstance> },
  ): UseMutationOptions<Awaited<ReturnType<typeof usersLoginCreate>>, TError, { data: NonReadonly<TokenObtainPair> }, TContext> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersLoginCreate>>, { data: NonReadonly<TokenObtainPair> }> = (props) => {
    const { data } = props ?? {};

    return usersLoginCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersLoginCreateMutationResult = NonNullable<Awaited<ReturnType<typeof usersLoginCreate>>>;
export type UsersLoginCreateMutationBody = NonReadonly<TokenObtainPair>;
export type UsersLoginCreateMutationError = UsersLoginCreateErrorResponse400;

export const useUsersLoginCreate = <TError = UsersLoginCreateErrorResponse400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersLoginCreate>>, TError, { data: NonReadonly<TokenObtainPair> }, TContext>, request?: SecondParameter<typeof queryInstance> },
  ): UseMutationResult<
  Awaited<ReturnType<typeof usersLoginCreate>>,
  TError,
  { data: NonReadonly<TokenObtainPair> },
  TContext
  > => {
  const mutationOptions = getUsersLoginCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Endpoint to refresh the user's `access_token` and `refresh_token`, from a valid `refresh_token`.
 */
export const usersLoginRefreshCreate = (
  tokenRefresh: NonReadonly<TokenRefresh>,
  options?: SecondParameter<typeof queryInstance>,
) => queryInstance<TokenRefresh>(
  { url: '/users/login/refresh/',
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tokenRefresh },
  options,
);

export const getUsersLoginRefreshCreateMutationOptions = <TError = UsersLoginRefreshCreateErrorResponse400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersLoginRefreshCreate>>, TError, { data: NonReadonly<TokenRefresh> }, TContext>, request?: SecondParameter<typeof queryInstance> },
  ): UseMutationOptions<Awaited<ReturnType<typeof usersLoginRefreshCreate>>, TError, { data: NonReadonly<TokenRefresh> }, TContext> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersLoginRefreshCreate>>, { data: NonReadonly<TokenRefresh> }> = (props) => {
    const { data } = props ?? {};

    return usersLoginRefreshCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersLoginRefreshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof usersLoginRefreshCreate>>>;
export type UsersLoginRefreshCreateMutationBody = NonReadonly<TokenRefresh>;
export type UsersLoginRefreshCreateMutationError = UsersLoginRefreshCreateErrorResponse400;

export const useUsersLoginRefreshCreate = <TError = UsersLoginRefreshCreateErrorResponse400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersLoginRefreshCreate>>, TError, { data: NonReadonly<TokenRefresh> }, TContext>, request?: SecondParameter<typeof queryInstance> },
  ): UseMutationResult<
  Awaited<ReturnType<typeof usersLoginRefreshCreate>>,
  TError,
  { data: NonReadonly<TokenRefresh> },
  TContext
  > => {
  const mutationOptions = getUsersLoginRefreshCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Endpoint to logout the user, by blacklisting it's `access_token` and `refresh_token`, from a valid
`refresh_token`.
 */
export const usersLogoutCreate = (
  tokenBlacklist: TokenBlacklist,
  options?: SecondParameter<typeof queryInstance>,
) => queryInstance<TokenBlacklist>(
  { url: '/users/logout/',
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: tokenBlacklist },
  options,
);

export const getUsersLogoutCreateMutationOptions = <TError = UsersLogoutCreateErrorResponse400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersLogoutCreate>>, TError, { data: TokenBlacklist }, TContext>, request?: SecondParameter<typeof queryInstance> },
  ): UseMutationOptions<Awaited<ReturnType<typeof usersLogoutCreate>>, TError, { data: TokenBlacklist }, TContext> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersLogoutCreate>>, { data: TokenBlacklist }> = (props) => {
    const { data } = props ?? {};

    return usersLogoutCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersLogoutCreateMutationResult = NonNullable<Awaited<ReturnType<typeof usersLogoutCreate>>>;
export type UsersLogoutCreateMutationBody = TokenBlacklist;
export type UsersLogoutCreateMutationError = UsersLogoutCreateErrorResponse400;

export const useUsersLogoutCreate = <TError = UsersLogoutCreateErrorResponse400,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersLogoutCreate>>, TError, { data: TokenBlacklist }, TContext>, request?: SecondParameter<typeof queryInstance> },
  ): UseMutationResult<
  Awaited<ReturnType<typeof usersLogoutCreate>>,
  TError,
  { data: TokenBlacklist },
  TContext
  > => {
  const mutationOptions = getUsersLogoutCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Endpoint to register users.
 */
export const usersRegisterCreate = (
  userRegister: NonReadonly<UserRegister>,
  options?: SecondParameter<typeof queryInstance>,
) => queryInstance<unknown>(
  { url: '/users/register/',
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: userRegister },
  options,
);

export const getUsersRegisterCreateMutationOptions = <TError = UsersRegisterCreateErrorResponse400 | UsersRegisterCreate403,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersRegisterCreate>>, TError, { data: NonReadonly<UserRegister> }, TContext>, request?: SecondParameter<typeof queryInstance> },
  ): UseMutationOptions<Awaited<ReturnType<typeof usersRegisterCreate>>, TError, { data: NonReadonly<UserRegister> }, TContext> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersRegisterCreate>>, { data: NonReadonly<UserRegister> }> = (props) => {
    const { data } = props ?? {};

    return usersRegisterCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersRegisterCreateMutationResult = NonNullable<Awaited<ReturnType<typeof usersRegisterCreate>>>;
export type UsersRegisterCreateMutationBody = NonReadonly<UserRegister>;
export type UsersRegisterCreateMutationError = UsersRegisterCreateErrorResponse400 | UsersRegisterCreate403;

export const useUsersRegisterCreate = <TError = UsersRegisterCreateErrorResponse400 | UsersRegisterCreate403,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersRegisterCreate>>, TError, { data: NonReadonly<UserRegister> }, TContext>, request?: SecondParameter<typeof queryInstance> },
  ): UseMutationResult<
  Awaited<ReturnType<typeof usersRegisterCreate>>,
  TError,
  { data: NonReadonly<UserRegister> },
  TContext
  > => {
  const mutationOptions = getUsersRegisterCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
